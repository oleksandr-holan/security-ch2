# Лабораторна робота

## Атака на навчальний вебсайт

### Крок 1 та 2: Знаходимо навчальний ресурс

В якості цільового ресурсу обрано навчальний сайт testphp.vulnweb.com, який дозволений для тестування вразливостей

### Крок 3: Використання SQL-дорків

Введіть у пошук Google цей запит:
`site:vulnweb.com inurl:php?artist=`

* `site:vulnweb.com` — ми обмежуємо пошук тільки цим легальним навчальним сайтом.
* `inurl:php?artist=` — це класична ознака (патерн) сторінки, яка приймає ID з бази даних. Це і є "дорк".

Google видасть вам результат, наприклад:
`http://testphp.vulnweb.com/artists.php?artist=1`

### Крок 4: Атака на ресурс

Тепер, коли ми знайшли вразливу сторінку через дорк, давайте її виконаємо ін'єкцію.

Відкрийте посилання:

`http://testphp.vulnweb.com/artists.php?artist=1'`

(Зверніть увагу на апостроф `'` в кінці).

Ми побачимо помилку: *Warning: mysql_fetch_array()...*
Це означає, що сайт вразливий! База даних "виплюнула" помилку, бо ми зламали синтаксис.

Ми хочемо змінити запит так, щоб він завжди був правдивим (тавтологія), або витягнути інші дані.

Спробуйте змінити URL в адресному рядку на такий:
`http://testphp.vulnweb.com/artists.php?artist=-1 OR 1=1`

`artist=-1`: ми просимо показати артиста з ID -1 (якого не існує).

`OR 1=1`: ми додаємо умову "АБО 1 дорівнює 1". Оскільки це завжди правда, база даних поверне всі записи.

Результат: Замість одного артиста, сторінка завантажить і всіх артистів з бази даних і покаже першого ліпшого, ігноручи ID.

Просунута атака (Витягуємо версію БД та користувача)

Вставте в адресний рядок цей пейлоад:
`http://testphp.vulnweb.com/artists.php?artist=-1 UNION SELECT 1,version(),3`

Ми побачимо на екрані версію MySQL (наприклад, `5.1.73-0ubuntu0.10.04.1`). Ми успішно виконали ін'єкцію і "злили" дані з сервера.

## Атака на власний вебсайт

### Етапи 1 та 2: Встановлення та запуск

1. Переконайтеся, що у вас встановлені **Docker** та **Docker Compose**.
2. Відкрийте термінал у папці `lab10`.
3. Виконайте команду:

    ```bash
    docker-compose up --build
    ```

4. Відкрийте браузер і перейдіть за адресою `http://localhost:8080`.

### Етап 3: Пошук "дорків" та вразливостей

Проналізуймо поля вводу створеного ресурсу.

* Ресурс приймає **Username** (ім'я користувача) та **Password** (пароль).
* Ми припускаємо, що SQL-запит у коді виглядає приблизно так: `SELECT ... WHERE username = '$user' ...`
* Щоб перевірити наявність SQL-ін'єкції, ми використовуємо символ одинарної лапки `'`, щоб спробувати "зламати" синтаксис рядка запиту.

#### Етап 4 та 5: Атака на ресурс (Payload)

Ми хочемо виконати **атаку тавтології** (зробити умову завжди істинною/true), щоб обійти аутентифікацію та отримати ("злити") дані з бази.

**Вектор атаки:**
Ми хочемо перетворити запит із такого вигляду:
`SELECT ... WHERE username = 'user' AND password = 'password'`
На такий:
`SELECT ... WHERE username = '' OR '1'='1' AND password = '' OR '1'='1'`

**Інструкція виконання:**

1. Перейдіть на сторінку `http://localhost:8080`.
2. У поле **Username** введіть точно цей рядок: `' OR '1'='1`
3. У поле **Password** введіть точно цей рядок: `' OR '1'='1`
4. Натисніть кнопку **Login**.

**Що відбувається?**
Бекенд на Go формує такий запит до бази даних:

```sql
SELECT id, username, password FROM users WHERE username = '' OR '1'='1' AND password = '' OR '1'='1'
```

Оскільки вираз `'1'='1'` завжди є істинним (true), база даних ігнорує перевірку реального пароля та повертає **всі рядки** з таблиці `users`.

**Результат:**
На веб-сторінці відобразиться:
> **Access Granted!** (Доступ дозволено!)
> **Dumped Data:** (Вивантажені дані:)
> `[{"id":1,"username":"admin","password":"supersecretkey"}, ...]`

Ми успішно обійшли систему аутентифікації та вивантажили паролі у відкритому вигляді (plain text) з бази даних.

### Етап 6: Модифікація коду web-ресурсу для захисту від SQL-ін’єкцій

Для усунення вразливості SQL Injection було проведено аналіз вихідного коду серверної частини (Backend) на мові Go. Виявлено, що причиною вразливості було використання конкатенації рядків при формуванні SQL-запиту, що дозволяло зловмиснику маніпулювати синтаксисом запиту.

Для захисту ресурсу було застосовано метод параметризованих запитів (Prepared Statements).

**Суть змін:**
Замість прямої вставки змінних у рядок запиту, використовуються спеціальні плейсхолдери (для PostgreSQL це `$1`, `$2`). Значення змінних передаються базі даних окремо від самого тіла запиту. Драйвер бази даних автоматично екранує дані, гарантуючи, що вони будуть сприйматися виключно як текстові літерали, а не як виконувані команди SQL.

**Порівняння коду:**

*Вразливий код (до модифікації):*

```go
// НЕБЕЗПЕЧНО: Пряма підстановка вхідних даних у рядок
query := fmt.Sprintf("SELECT id, username, password FROM users WHERE username = '%s' AND password = '%s'", creds.Username, creds.Password)
rows, err := db.Query(query)
```

*Захищений код (після модифікації):*

```go
// БЕЗПЕЧНО: Використання параметризованого запиту
query := "SELECT id, username, password FROM users WHERE username = $1 AND password = $2"

// Аргументи передаються окремим параметром функції
rows, err := db.Query(query, creds.Username, creds.Password)
```

### Етап 7: Повторна перевірка на вразливість

Після оновлення програмного забезпечення на сервері та перезапуску контейнерів Docker, було проведено повторну спробу SQL-ін'єкції з використанням того ж вектору атаки, що був успішним на попередньому етапі.

**Хід перевірки:**

1. Відкрито сторінку авторизації оновленого ресурсу.
2. У поле **Login** введено пейлоад: `' OR '1'='1`
3. У поле **Password** введено пейлоад: `' OR '1'='1`
4. Натиснуто кнопку входу.

**Результат:**
Система відмовила у доступі, видавши повідомлення **"Access Denied (Attack Failed)"** (або код відповіді HTTP 401 Unauthorized).

**Аналіз результату:**
Атака не вдалася, оскільки база даних отримала запит, у якому шукала користувача, чиє ім'я буквально співпадає з рядком `' OR '1'='1`. Оскільки такого користувача в базі немає, і логічні оператори `OR` були сприйняті як частина тексту, а не як команди, умова `WHERE` не виконалася.

**Висновок:**
Використання параметризованих запитів повністю усунуло вразливість SQL Injection даного типу. Ресурс захищено.

Ось розгорнуті відповіді на контрольні питання до лабораторної роботи, адаптовані під вашу практичну реалізацію (Go + PostgreSQL).

## Відповіді на питання до лабораторної роботи

1. Що таке SQL-ін’єкція, для чого вона використовується та коли працює?

    SQL-ін’єкція (SQL Injection) — це тип атаки на веб-додатки, при якій зловмисник втручається в запити, що додаток відправляє до бази даних. Це досягається шляхом введення шкідливого SQL-коду в поля вводу (форми, URL-параметри, заголовки HTTP).

    Для чого використовується:

    * Обхід аутентифікації: Вхід у систему без знання пароля (як ми зробили в лабораторній).
    * Крадіжка даних (Dumping): Отримання доступу до конфіденційної інформації (паролі, особисті дані клієнтів).
    * Зміна або видалення даних: Зловмисник може змінити баланс рахунку, видалити таблиці тощо.

    Коли працює: Атака можлива тоді, коли веб-додаток бере дані, введені користувачем, і напряму "склеює" (конкатенує) їх з рядком SQL-запиту без попередньої перевірки, очищення або екранування.

2. Які вразливості повинні мати ресурси, щоби можна було здійснити атаку такого типу? Покажіть це на прикладі коду Вашого ресурсу.

    Ресурс повинен мати вразливість відсутності санітизації вхідних даних та використання динамічного формування SQL-запитів через конкатенацію рядків.

    Приклад з коду лабораторної (мова Go):

    У незахищеній версії ми використовували функцію `fmt.Sprintf`, яка просто підставляла текст із форми прямо в команду бази даних.

    ```go
    // Вразливий код
    // Зловмисник може ввести " ' OR '1'='1 " і змінити логіку запиту
    query := fmt.Sprintf("SELECT ... WHERE username = '%s' AND password = '%s'", creds.Username, creds.Password)
    
    // Результат, який виконує база:
    // SELECT ... WHERE username = '' OR '1'='1' AND ...
    ```

    Оскільки розробник довіряє введенню користувача і не відділяє дані від коду команди, інтерпретатор SQL виконує введені символи як частину логіки (оператор `OR`), а не як просто текст.

3. Розкажіть про методику виконання SQL-ін’єкції та продемонструйте цю атаку на Вашому відео або “вживу”.

    Методика виконання атаки складається з таких етапів:

    1. Розвідка (Reconnaissance): Пошук точок входу, де дані користувача передаються на сервер (форми логіну, пошуку, ID в URL).
    2. Тестування (Fuzzing): Введення спецсимволів (найчастіше одинарної лапки `'`, подвійної лапки `"`, крапки з комою `;`), щоб спробувати викликати помилку бази даних. Поява помилки свідчить про те, що синтаксис запиту порушено, і вразливість існує.
    3. Впровадження пейлоаду (Exploitation): Введення спеціально сформованих команд.
        * Приклад атаки "Тавтологія" (використаний в ЛР): Введення `' OR '1'='1`. Це робить умову запиту завжди істинною (`TRUE`), що змушує базу повернути перший знайдений запис (зазвичай адміністратора) або всі записи.
        * Приклад атаки "UNION": Використання оператора `UNION SELECT`, щоб приєднати до результатів запиту дані з інших таблиць (наприклад, версію БД або таблицю користувачів).

4. Сформулюйте вимоги до web-розробки, захищеної від такого типу атак.

    Щоб уникнути SQL-ін'єкцій, розробники повинні дотримуватися таких вимог:

    1. Використання параметризованих запитів (Prepared Statements): Це головна вимога. Всі дані, що надходять від користувача, повинні передаватися в базу даних через плейсхолдери (наприклад, `$1`, `?`, `:name`). Це гарантує, що БД сприйматиме їх виключно як дані, а не як виконуваний код.
    2. Валідація вхідних даних (Input Validation): Перевірка даних на відповідність очікуваному типу. Наприклад, якщо очікується `id` (число), то сервер повинен відхилити будь-які букви чи символи ще до запиту в БД.
    3. Принцип найменших привілеїв (Least Privilege): Користувач бази даних, під яким працює веб-сайт, повинен мати доступ тільки до тих таблиць, які йому необхідні, і не повинен мати прав адміністратора (наприклад, прав на видалення таблиць `DROP TABLE`).
    4. Використання ORM (Object-Relational Mapping): Сучасні ORM (як GORM для Go, Hibernate для Java, Entity Framework для C#) зазвичай використовують параметризовані запити за замовчуванням, що зменшує ризик помилки розробника.
